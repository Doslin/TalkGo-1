# 第 2 阶段课程笔记

## 07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）

一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所以这种情况一定要避免。

思考：

工作中就遇到这个问题，软件看门狗出现异常，频繁启动后台业务进程，导致进程号等资源用尽，系统瘫痪只能重启恢复。



## 08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）

iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。

因此，碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。





## 09 | 基础篇：怎么理解Linux软中断？

Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：

上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。

下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。

这两个阶段你也可以这样理解：

**上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；**

**而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。**

如何查看？

**/proc/softirqs 提供了软中断的运行情况；**

**/proc/interrupts 提供了硬中断的运行情况。**

运行下面的命令，查看 /proc/softirqs 文件的内容，你就可以看到各种类型软中断在不同 CPU 上的累积运行次数：

```

[root@localhost ~]# cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3
          HI:          0          0          0          1
       TIMER:    7162062   14778047    4809839   12123095
      NET_TX:          1     190439          3          2
      NET_RX:    2011702    2542076     524800    1462328
       BLOCK:      16202      20016      70112     443356
BLOCK_IOPOLL:          0          0          0          0
     TASKLET:     145402         80         11       1135
       SCHED:    2100823    4027617    2452375    5694855
     HRTIMER:          0          0          0          0
         RCU:    4138367    7838168    2880635    6074916
[root@localhost ~]#

```

Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型。

**在 Linux 中，每个 CPU 都对应一个软中断内核线程，名字是 ksoftirqd/CPU 编号**



扩展阅读参考：

<https://xinqiu.gitbooks.io/linux-insides-cn/content/Interrupts/linux-interrupts-9.html>



## 10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？

观察 /proc/softirqs 文件的内容，你就能知道各种软中断类型的次数。这里的各类软中断次数，是系统运行以来的累积中断次数。

所以我们直接查看文件内容，得到的只是累积中断次数，对这里的问题并没有直接参考意义。因为，**这些中断次数的变化速率才是我们需要关注的**。

sar  可以用来查看系统的网络收发情况，还有一个好处是，不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒收发的网络帧数。

```

01:56:44 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
01:56:44 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
01:56:44 PM virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00
01:56:44 PM    virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00
01:56:44 PM eno16780032      5.26     10.53      0.59      1.42      0.00      0.00      0.00

Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:    virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:       virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:    eno16780032      4.41      1.32      0.33      0.17      0.00      0.00      0.00

```

对于 sar 的输出界面：

第一列：表示报告的时间。

第二列：IFACE 表示网卡。

第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是  PPS。

第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是  BPS。



软中断 CPU 使用率（softirq）升高是一种很常见的性能问题。虽然软中断的类型很多，但实际生产中，**我们遇到的性能瓶颈大多是网络收发类型的软中断，特别是网络接收的软中断。**



一个软中断的例子：

<https://blog.huoding.com/2013/10/30/296>



## 11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？

### CPU 性能指标

#### CPU使用率

CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。

用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。

用户 CPU 使用率高，通常说明有应用程序比较繁忙。

系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。

系统 CPU 使用率高，说明内核比较繁忙。

等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。

iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。

软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。

除了上面这些，还有在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。

#### 平均负载

平均负载（Load Average），也就是系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。

理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。

#### 进程上下文切换

进程上下文切换，包括：无法获取资源而导致的自愿上下文切换；被系统强制调度导致的非自愿上下文切换。

#### CPU 缓存的命中率



### 性能工具

#### 根据指标找工具

**第一个维度，从 CPU 的性能指标出发。也就是说，当你要查看某个性能指标时，要清楚知道哪些工具可以做到。**

![根据指标找工具](https://github.com/hwangyungping/TalkGo/blob/master/TalkGo读书会--第一期/PIC/02-01.png)

#### 根据工具找指标

**第二个维度，从工具出发。也就是当你已经安装了某个工具后，要知道这个工具能提供哪些指标。**

![根据工具查指标](https://github.com/hwangyungping/TalkGo/blob/master/TalkGo读书会--第一期/PIC/02-02.png)

#### 如何迅速分析 CPU 的性能瓶颈

虽然 CPU 的性能指标比较多，但要知道，既然都是描述系统的 CPU 性能，它们就不会是完全孤立的，很多指标间都有一定的关联。

**想弄清楚性能指标的关联性，就要通晓每种性能指标的工作原理。**

这也是为什么我在介绍每个性能指标时，都要穿插讲解相关的系统原理，希望你能记住这一点。

举个例子，用户 CPU 使用率高，我们应该去排查进程的用户态而不是内核态。

因为用户 CPU 使用率反映的就是用户态的 CPU 使用情况，而内核态的 CPU 使用情况只会反映到系统 CPU 使用率上。

你看，有这样的基本认识，我们就可以缩小排查的范围，省时省力。

所以，为了缩小排查范围，**我通常会先运行几个支持指标较多的工具，如 top、vmstat 和 pidstat 。**为什么是这三个工具呢？仔细看看下面这张图，你就清楚了

**三步排查大法**

![三步排查法](https://github.com/hwangyungping/TalkGo/blob/master/TalkGo读书会--第一期/PIC/02-03.png)

这三个命令，几乎包含了所有重要的 CPU 性能指标，比如：

**从 top 的输出可以得到各种 CPU 使用率以及僵尸进程和平均负载等信息。**

**从 vmstat 的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数。**

**从 pidstat 的输出可以得到进程的用户 CPU 使用率、系统 CPU 使用率、以及自愿上下文切换和非自愿上下文切换情况。**



